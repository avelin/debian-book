\chapter{Първоначално запознаване с Debian}

\section{Процес на стартиране на Debian GNU/Linux}

Когато включите компютъра си, първото нещо, което той прави, е да провери дали всичко
е наред с хардуера. След това програма, наречена "bootstrap loader", търси boot-sector 
(сектор за начално зареждане). Boot-секторът е първият сектор от твърдия диск
и в него има малка програма, която може да зарежда операционни системи. Тази
програма не може да да бъде по--голяма от 512 байта. Boot секторът може също да се
намира на дискета или CD. Когато bootstrap-програмата намери boot-сектор, го зарежда в
паметта и се изпълнява програмата, която зарежда операционната система. Обикновено,
когато на компютъра е инсталиран GNU/Linux, тази програма е \texttt{LILO}
(\textbf{LI}nux \textbf{LO}ader). Debian използва \texttt{LILO}. Освен \texttt{LILO}
можете да използвате и по-малко известния \texttt{grub} (друга програма за зареждане 
на операционни системи).

Когато компютърът зареди boot-сектор на нормална GNU/Linux система, той всъщност зарежда
част от \texttt{LILO}, наречена "first stage boot loader (първо ниво)". Неговата
работа е да зареди "second stage boot loader (второ ниво)". Второто ниво Ви запитва
каква операционна система искате да се зареди.

Ако изберете Linux, се зарежда ядрото (обикновено \texttt{/vmlinuz}).FIXME! Ядрото
всъщност е самата операционна система. То отговаря за комуникацията на софтуера с
хардуера. Когато ядрото се зареди напълно, първата програма, която изпълнява, е
\texttt{/sbin/init}. За подробности може да погледнете \man{init}{8} man-страницата. 
Просто напишете:

\begin{verbatim}
$ man 8 init
\end{verbatim}
или само
\begin{verbatim}
$ man init
\end{verbatim}

Ако обаче не намери \texttt{/sbin/init}, ядрото (говорим за ядра, версия 2.4.x)
търси \texttt{/etc/init}, \texttt{/bin/init}. Ако и тези не съществуват, ядрото
изпълнява шел \texttt{/bin/sh}. Ако обаче и /bin/sh не съществува, системата не се
стартира, а вместо това виждате следното съобщение: \texttt{"No init found. Try
passing init= option to kernel."}.

Ако получите такова съобщение, можете да стартирате ядрото, задавайки следните
параметри на \texttt{LILO}:

\begin{verbatim}
LILO: Linux init=/bin/bash
\end{verbatim}

По този начин казвате на ядрото да не се изпълнява \texttt{/sbin/init}, а
\texttt{/bin/bash}, което ще Ви осигури шел (shell) веднага след зареждане на
ядорото в паметта. Имайте предвид, че системата няма да се държи както обикновено
(след малко ще разберете защо). Най-простият пример за това е, че не можете да
видите процесите на системата (ако се чудите защо --- защото \texttt{/proc}
файловата система не е монтирана. За да я монтирате просто напишете:

\begin{verbatim}
mount /proc
\end{verbatim}

На практика можете да замените \texttt{/sbin/init} с каквато решите програма, но не
е препоръчително, освен ако \textbf{наистина} знаете какво правите :-).

Работата на \texttt{init} е да прочете файла \texttt{/etc/inittab} и в зависиост от
съдържанието му да изпълни определени скриптове след зареждане на ядрото, наречени
\textbf{rc} скриптове. Те имат за цел да стартират определени услуги (програми) при
стартиране на системата (например графичната среда, уебсървъра, демона за водене
на отчетни файлове, виртуалните терминали и други) и да ги спират при изключване на
системата. Когато се стартират тези скриптове, системата може да премине в различни
нива (runlevels), а те са: еднопотребителски режим, многопотребителски режим,
спиране на системата или рестартиране. Нивата на изпълнение са описани в
\texttt{/etc/inittab}:

\begin{verbatim}
# Runlevel 0 is halt. (спиране на системата)
# Runlevel 1 is single-user. (еднопотребителски режим)
# Runlevels 2-5 are multi-user. (многопотребителски режим)
# Runlevel 6 is reboot. (рестартиране на системата)
\end{verbatim}

Ако искате да смените режима, в който системата по принцип влиза при стартиране ---
търсете ред в \texttt{/etc/inittab}, подобен на този:

\begin{verbatim}
id:ниво:initdefault:
\end{verbatim}

Стойностите на "ниво" могат да бъдат 1, 2, 3, 4 или 5. В противен случай системата
няма да се стартира.

Еднопотребителският режим е по-специален. Когато системата се стартира в този
режим, тя всъщност иска паролата на root-потребителя и му предоставя шел, ако е
вярна. В този режим не се отварят виртуални терминали и никой друг не може да влезе
в системата. Този режим се използва главно, когато нещо в системата не е наред и
трябва да се оправи или при сериозна промяна в системната конфигурация като 
реорганизиране на дяловете, форматиране на файлови системи и въобще мащабни операции, 
а също и при провеждане на тестове върху системата.

Когато една Debian-система се стартира, тя преминава в runlevel 2
(многопотребителски режим). Тогава се изпълняват скриптовете в директория
\texttt{/etc/rc\textbf{2}.d/}, които пък сами по себе си са символни връзки (за
повече информация прочетете man страницата на \man{ln}{1}) към скриптовете в
\texttt{/etc/init.d/}. В \texttt{/etc/init.d/} се намират всички
\textbf{rc} скриптове. Различните нива имат директории
\texttt{/etc/rc\textbf{ниво}.d/}. Така че, ако искате да промените скриптовете,
които се изпълняват при стартиране на системата --- отивате в директория
\texttt{/etc/rc\textbf{2}.d/}.

За по--любознателните --- кодът, който определя коя
програма да се изпълни след зареждане на ядрото, се намира във файла
\texttt{/usr/src/linux/init/main.c} (последните няколко реда).

\section{Вход и изход от системата}

\subsection{Първоначална идентификация}

Когато стартирате своята Debain-система, първото, което трябва да направите 
след като системата е заредила успешно, е да се идентифицирате. Debian ще 
очаква да направите това, като ви предостави login prompt, 
който изглежда примерно така:

\begin{verbatim}

Debian GNU/Linux testing/unstable shodan tty1

shodan login:
\end{verbatim}

При вас разбира се ще изглежда малко по-различно (най-малкото, заради името на хоста), 
а също така е взможно и този процес при вас да се извършва в графичен режим, 
вместо текстово като при мен, при положение че системата ви е конфигурирана с XWindow 
(kdm, gdm или xdm). 

След въвеждането на потребителското име, ще трябва да се идентифицираме и с парола:

\begin{verbatim}
Debian GNU/Linux testing/unstable shodan tty1

shodan login:manchev
Password:
\end{verbatim}

След успешната идентификация, Debian ще ни предостави своя prompt, който при мен 
изглежда така:

\begin{verbatim}
manchev@shodan:~$
\end{verbatim}

% $ -- затваряне на долара във verbatim

Важно е да отбележим, че описанията и примерите, които ще даваме и обясняваме, в случая 
засягат работата на Debian през конзола, така че ако използвате графична среда, сега е 
моментът да отворите терминална емулация на конзолата. 

Преди да се захванем с най-основите команди, които може да изпълнявате, трябва 
да обърнем внимание на два основни аспекта. След като вече сте получили оторизация за 
използването на системата, може да се наложи да оставите компютъра без надзор, 
което е опасно от гледна точка на сигурността. Освен това, трябва да 
знаете как правилно да изключвате системата.
И така, когато трябва да стане от работното си място, добра идея е 
да се изключите от системата, за да не може някои да използва вашето 
име и вашите права в нея с недобронамерени цели. 
За изключване от системата напишете на промпта:

\begin{verbatim}
manchev@shodan:~$logout
\end{verbatim}

% $ -- затваряне на долара във verbatim

Това ще ни върне в стартовото състояние и на екрана ще се изведе частта, очакваща 
идентификация:

\begin{verbatim}
Debian GNU/Linux testing/unstable shodan tty1

shodan login:
\end{verbatim}

Когато искате да изключите компютъра изобщо, трябва да изпълните друга командата --- shutdown. 
Важно е да се отбележи, че това е задължителна стъпка, понеже директното щракване 
на копчето крие рискове от загуба на данни --- Linux поддържа кеш спрямо дисковете си, 
като времето на опресняване е от порядъка на 30 секунди. Спрете ли системата направо от 
захранването, рискувате загуба на информация, която все още не е прехвърлена към 
дисковата система. 

\subsection{shutdown}

Командата \man{shutdown}{8} се използва за изключване на системата чисто и безопасно. 
Когато изпълните командата shutdown всички включени в системата потребители (локални или 
отдалечени) получават нотификация, че системата прекратява работа. Освен това се поставя 
и забрана за включване на нови потребители. Следващата стъпка, която \man{shutdown}{8} 
предприема е да изпрати сигнала \texttt{SIGTERM} до всички работещи към момента процеси. 
Това дава възможност на програмите, които го разпознават да приключат нормално работата си 
(например даден текстови редактор разбира, че системата се готви за изключване и може да 
запази данни от файла, който в момента се редактира чрез него). По-нататък \man{shutdown}{8} 
се свързва с процеса \man{init}{8}, като заявява смяна на \man{runlevel}{8}, като стойността 
по подразбиране е runlevel 1. (FIXME: Да се обясни)
Има няколко важни параметъра, които можем да укажем на командата, а именно:

-r Параметърът изисква от системата да се рестартира, след като приключи изпълнението на 
процесите, които shutdown изисква.

-h Блокира всякакъв достъп към системата. Обикновено точно този параметър се използва, 
когато смятаме да изключим изцяло компютъра.

Освен това, командата shutdown изисква и един задължителен параметър "- time", който казва 
кога да се извърши изключването. Той може да се замени с константата "now", което инструктира 
shutdown да започне процеса незабавно. 

От казаното по-горе можем да конструираме два от основните формати на извикване на shutdown, 
а именно:

\begin{itemize}
\item Преди да изгасим компютъра:

\begin{verbatim}
manchev@shodan:~$shutdown now -h
\end{verbatim}

% $ -- затваряне на долара във verbatim

\item Или когато искаме просто да го рестартираме:

\begin{verbatim}
manchev@shodan:~$shutdown now -r
\end{verbatim}
\end{itemize}

% $ -- затваряне на долара във verbatim

Ако сега се опитам да изпълня една от двете команди на моята система, това което ще се случи 
няма да е очакваното:

\begin{verbatim}
manchev@shodan:~$shutdown now -r
bash: shutdown: command not found
\end{verbatim}

% $ -- затваряне на долара във verbatim

Bash (FIXME:Две думи за Bourne и C shell)  ни съобщава, че не е намерил изисканата от нас 
команда. Това се случва по простата причина, че ние като обикновен потребител нямаме в пътя 
си достъп до \texttt{/sbin} директорията от файловата система, коята съдържа в команди достъпни 
единствено за администраторите на системата. Дори и да отидем в самта директория и да изпълним 
командата там (което е постижимо), ще видим нещо от рода на:

\begin{verbatim}
shutdown: you must be root to do that!
\end{verbatim}

Ако помислим логично --- тази защита е съвсем уместна. Ние не бихме искали всеки потребител на 
когото сме дали някакъв достъп до системата да има възможност да я изключва и рестартира. Което 
ни води до следващата крачка: Ако не използваме системата като root, но въпреки това 
администрираме системата, как да извършим операциите по изключването и рестартирането й?

Тук е момента да споменем още една основна команда --- \man{su}{1}. Тя ни дава възможност 
да сменим своята идентификация и в частност да се превърнем \texttt{superuser}, който има права 
да извърши дадената операция.

\subsection{su}

Както вече споменахме, su ни дава възможност да се превърнем в друг потребител по време на
нашата собствена сесия. Ако извикаме командата без име на потребител, чиито права искаме да 
придобием, тогава по подразбиране su предполага, че искаме да се превърнем в root. Важно е да 
обърнем внимание на параметъра "\-", който се използва за да придобием и обкръжението, което 
потребителят в който се превръщаме би получил ако се включи директно към системата. Например, 
ако се превръщаме в нормален потребител, стойността на на променливата (FIXME: DOLLAR)PATH ще 
се промени на \texttt{/bin:/usr/bin} или ако се идентифицираме като super user, нейната стойност 
ще бъде \texttt{/sbin:/bin:/usr/sbin:/usr/bin}.

Друг итнересен параметър на командата е "-c" чрез който направо изпълняваме дадена команда с 
правата на потребителя, в който се превръщаме.

От тук насетне имаме два подхода: Първият е да се превърнем в super user и да изпълним командата 
\man{shutdown}{8}, а вторият --- да извикаме \man{su}{1} и направо да поискаме той да изпълни 
\man{shutdown}{8} с права нa \texttt{superuser}. 

Първият подход изглежда така:

\begin{verbatim}
manchev@shodan:~$su -
Password:
\end{verbatim}

% $ -- затваряне на долара във verbatim

След като желаем да се превърнем в \texttt{root}, системата изисква да напишем паролата за 
акаунта на този потребител. След като я въведем правилно ще получим нов промпт:

\begin{verbatim}
shodan:~#
\end{verbatim}

Обърнете внимание в промяната на знака \$ в \#. Именно заради тази промяна винаги можем 
да знаем като какъв потребител използваме конзолата --- нормален когато промпта е \$ или
\texttt{root} когато промпта е \#.

Изпълняваме \man{shutdown}{8}:

\begin{verbatim}
shodan:~#shutdown now -h

Broadcast message from root (tty1) 

The system is going down for system halt NOW!
INIT: Switching to runlevel: 0
INIT: Sending processes the TERM signal
INIT: Sending processes the KILL signal
Stopping periodic command scheduler: cron.
Stopping initernet superserver: inetd.
Stopping OpenBSD Secure Shell server: sshd.
Saving the System Clock time to the Hardware Clock...
Hardware Clock updated to Tue Aug 19 13:23:37 EEST 2003.
Stopping deferred execution scheduler: atd.
Stopping kernel log daemon: klogd.
Stopping system log daemon: syslogd.
Sending all processes the TERM signal... done.
Sending all processes the KILL signal... done.
Saving random seed... done.
Unmounting remote filesystems... done.
Deconfiguring network interfaces.... done.
Deactivating swap... done.
Unmounting local filesystems... mount: proc already mounted
done.
flushing ide devices: hda hdc
Power down.
\end{verbatim}

Е, сега е безопасно да изключите компютъра си, ако той сам не се е изключил разбира се.

Другият вариант беше да напишем направо:

\begin{verbatim}
manchev@shodan:~$su -c "shutdown now -h"
Password:
\end{verbatim}

% $ -- затваряне на долара във verbatim

И след въвеждането на паролата, щеше да последва същата поредица от действия 
(FIXME: Да не забравя за sudo).

Когато говорим за изключване или рестартиране на системата, трябва да обърнем внимание и 
на командите \man{halt}{8}, \man{reboot}{8} и \man{poweroff}{8}. Какво правят те е видно 
от самите им имена. Да вземем за пример действието на \man{halt}{8}. Ако изпълним 
\man{halt}{8} и не се намираме в \man{runlevel}{8} 0 или 6 (тоест --- нормално функционираща 
система) Debian ще изпълни \texttt{shutdown -h} (респективно \texttt{shutdown -r}, ако извикаме 
\man{reboot}{8}). С една дума може да гледаме на \man{halt}{8} като синоним на
\texttt{shutdown -h}. В по-старите версии на \deb{sysvinit} не беше разрешно \man{halt}{8} 
да се извиква директно. Така или иначе употребата на \man{shutdown}{8} е по-елегантния начин 
за изключване/рестарт и най-добре се придържайте към него.

След като видяхме как правилно можем да се включим, изключим и как безопасно да спрем 
системата, вече е време да започнем да се забавляваме с основните команди на Debian GNU/Linux.

\section{Разглеждане на файлове с ls}

Първото нещо, което веднага ни идва на ум е да видим какво има в системата, след като веднъж 
сме се идентифицирали в нея и притежаваме определни права. Тук е моментът да се запознаем 
с командата \man{ls}{1}. Това е една от основните команди на Linux. Това, което тя прави 
е да покаже списък (list --- ls, връзката е ясна) от файлове. Когато изпълняваме \man{ls}{1} 
без параметри по подразбиране се показва списъка с файловете от текущата директория. Нека опитаме:

\begin{verbatim}
manchev@shodan:~$ls
manchev@shodan:~$
\end{verbatim}

Малко неочаквано, но разбираемо. Като нов потребител на системата в моята директория все още 
няма никакви файлове. Все пак, за да проверим дали \man{ls}{1} върши изобщо нещо, нека я изпълним 
с параметър "/". 

\begin{verbatim}
manchev@shodan:~$ls /
bin   cdrom  etc     home    lib         mnt  proc  root-n  tmp  var
boot  dev    floppy  initrd  lost+found  opt  root  sbin    usr
\end{verbatim}

% $ -- затваряне на долара във verbatim

Така нещата изглеждат по-нормални. Това което накарахме \man{ls}{1} да ни покаже е основната 
директория на нашата система. Основната директория е пределно позната концепция от множество 
операционни системи. Тя е коренът, от който дървовидно се разраства цялата файлова система 
на Debian. 

Видяхме, че можем да предаваме като параметър на \man{ls}{1} коя част от файловата струткура 
искаме да разгледаме. Можем например да опитме да видим директориите на регистрираните в 
системата потребители. Всеки акаунт на потребител който добавяме към системата автоматично 
получава и собствена директория в нея, където той може да държи файловете си. Тези директории 
по подразбиране се създават в \texttt{/home}. Да погледнем:

\begin{verbatim}
manchev@shodan:~$ls /home
manchev
manchev@shodan:~$
\end{verbatim}

Тук виждаме само една единствена директория --- моята собствена. Това е така, понеже в момента 
аз съм единствения регистриран ползвател на моя Debian. 

Ако все пак сте любопитни, къде е директорията на потребителя \texttt{root}, в който се 
превърнахме за да изключим системата, отговорът е, че \texttt{root} има собствена директория 
извън \texttt{home}, която е разположена в основната директория. Можете да я видите под името 
\texttt{root} на изхода от изпълнението на командата \texttt{ls /} по-горе.

Нека все пак отбележим, че не всички акаунти имат свои директории в \texttt{home}. Има различни 
служебни потребители, за които няма смисъл да се създават такива. Например \texttt{mail}, чиито 
права се използват от частта по обслужване на пощенската система.

Освен простото изписване на имената, \man{ls}{1} може да показва още много допълнителна информация. 
Командата е изключително мощна и богата на параметри, както междувпрочем и повечето команди на Debian. 

Нека вземем за пример параметъра "-F". Да изпълним:

\begin{verbatim}
manchev@shodan:~$ls -F /
bin/   cdrom/  etc/     home/    lib/        mnt/  proc/  root-n*  tmp/  var/
boot/  dev/    floppy/  initrd/  lost+found  opt/  root/  sbin/  usr/
\end{verbatim}

% $ -- затваряне на долара във verbatim

Сега получаваме повече информация за отделните файлове в основната директория. Параметърът "-F" кара 
\man{ls}{1} да постави допълнителен идентификатор до всеки запис, който ни показва какъв е неговия тип. 
Знакът "/" е указател за директория, "*" показва че записът е  изпълним файл, "@" обозначава символни 
линкове (FIXME: За symlinks/hard links да се каже) , "=" се прикрепя към сокети и "|" за FIFO 
(FIXME: За FIFO да се каже).

Има още няколко основни параметъра, които е добре да разгледаме. Един много важен и често използван 
параметър на \man{ls} е "-l", който кара командата да изведе списъка в по-разширен формат. Да опитаме:

\begin{verbatim}
manchev@shodan:~$ls -l /

total 100
drwxr-xr-x    2 root     root         4096 Aug 17 18:19 bin
drwxr-xr-x    2 root     root         4096 Aug 19 08:53 boot
drwxr-xr-x    2 root     root         4096 Aug 17 17:37 cdrom
drwxr-xr-x    9 root     root        24576 Aug 19 18:25 dev
drwxr-xr-x   49 root     root         4096 Aug 19 19:38 etc
drwxr-xr-x    2 root     root         4096 Aug 17 17:37 floppy
drwxrwsr-x    3 root     staff        4096 Aug 19 19:38 home
drwxr-xr-x    2 root     root         4096 Aug 17 17:37 initrd
drwxr-xr-x    5 root     root         4096 Aug 17 22:14 lib
drwx------    2 root     root        16384 Aug 17 16:32 lost+found
drwxr-xr-x    2 root     root         4096 Feb  8  2002 mnt
drwxr-xr-x    2 root     root         4096 Aug 17 17:37 opt
dr-xr-xr-x   34 root     root            0 Aug 19 18:25 proc
drwxr-xr-x    9 root     root         4096 Aug 19 20:12 root
-rwxr-xr-x    1 root     root            0 Aug 18 19:18 root-n
drwxr-xr-x    2 root     root         4096 Aug 17 18:19 sbin
drwxrwxrwt    5 root     root         4096 Aug 19 20:11 tmp
drwxr-xr-x   12 root     root         4096 Aug 18 00:07 usr
drwxr-xr-x   13 root     root         4096 Aug 17 17:37 var
\end{verbatim}

% $ -- затваряне на долара във verbatim

Изходът от изпълнението започва с реда "total <блокове>".  Стойността на тези блокове показва 
размера на дисковото пространство, което заемат файловете в директорията. По подразбиране 
един блок се равнява на 1024 байта, но тази стойност може да се променя с подхящи параметри 
на \man{ls}{1}.

По-нататък за всеки отделен запис се извежда информация както следва: права, брой на твърдите 
връзки на файла или ако е директория --- броя на твърдите връзки на файловете в нея, име на 
притежателя на файла, име на групата, размер и времето на последна модификация. Смисълът на 
тези данни ще разгледаме по-късно, когато видим употребата на различните команди по раздаване 
на права, смяна на собственост на файлове и т.н.

Последното, което ще споменем за \man{ls}{1} e параметъра "-h". Той предоставя същата 
информация но във вид, който е удобен за четене от потребителя. Разбира се, чудесно е да 
знаем размера на всеки файл до байт, но е къде по-лесно за възприемане, ако той се конвертира 
автоматично до KB, MB или GB (в зависимост от размера си), защото така е по-удобен за възприемане.

Като последен пример за \man{ls}{1}, нека изпълним командата с два параметъра --- "-l" и "-h". 
Ето как изглежда изхода от изпълнението:

\begin{verbatim}
manchev@shodan:~$ls -l -h

total 100K
drwxr-xr-x    2 root     root         4.0K Aug 17 18:19 bin
drwxr-xr-x    2 root     root         4.0K Aug 19 08:53 boot
drwxr-xr-x    2 root     root         4.0K Aug 17 17:37 cdrom
drwxr-xr-x    9 root     root          24K Aug 19 18:25 dev
drwxr-xr-x   49 root     root         4.0K Aug 19 19:38 etc
drwxr-xr-x    2 root     root         4.0K Aug 17 17:37 floppy
drwxrwsr-x    3 root     staff        4.0K Aug 19 19:38 home
drwxr-xr-x    2 root     root         4.0K Aug 17 17:37 initrd
drwxr-xr-x    5 root     root         4.0K Aug 17 22:14 lib
drwx------    2 root     root          16K Aug 17 16:32 lost+found
drwxr-xr-x    2 root     root         4.0K Feb  8  2002 mnt
drwxr-xr-x    2 root     root         4.0K Aug 17 17:37 opt
dr-xr-xr-x   34 root     root            0 Aug 19 18:25 proc
drwxr-xr-x    9 root     root         4.0K Aug 19 20:12 root
-rwxr-xr-x    1 root     root            0 Aug 18 19:18 root-n
drwxr-xr-x    2 root     root         4.0K Aug 17 18:19 sbin
drwxrwxrwt    5 root     root         4.0K Aug 19 20:11 tmp
drwxr-xr-x   12 root     root         4.0K Aug 18 00:07 usr
drwxr-xr-x   13 root     root         4.0K Aug 17 17:37 var
\end{verbatim}

% $ -- затваряне на долара във verbatim

Нека обърнем внимание на още един факт. В \man{ls}{1}, както и в повечето Debian команди може 
да комбинирате параметри и да ги подавате заедно към командата, за която се отнасят. Например, 
вместо "ls -l -h" можехме да напишем "ls -lh". 

Командата \man{ls} е много мощен инструмент. Тя може да извежда различна информация в множество 
различни формати. Да сортира, да филтрира, да навлиза и показва съдържанието на директории, да 
поддържа контролни знаци. Изобщо --- каквото ви дойде наум. Това е валидно за почти всички 
команди на Debian --- изключително богатство от функции, достъпни чрез определени параметри и 
гъвкаво управление на изпълнението. 

Разбира се, ние не можем да опишем всички параметри и възможности на всяка команда, която 
разглеждаме. Това, което можем да покажем обаче е как да получите помощ за всяка една от тях. 
Това е следващата тема, която ще разгледаме.

Преди това, нека споменем и още една команда, с аналогични функции на \man{ls}{1}. Това е 
командата \man{dir}{1}. Когато говорим за системата за помощ на Debian ще разберете как да 
получите повече информация за нея (ако разбира се ви интересува). Така или иначе, \man{ls}{1} 
и \man{dir}{1} вършат едно и също, въпреки че имат някои разлики. По-голямата част от 
потребителите на Debian, които познавам се придържат твърдо към \man{ls}{1}. Както и аз самият. 
Моят личен е избор е продиктуван от две неща :

\begin{enumerate} 
\item свикнал съм с ls, защото в първия Linux който ползвах нямше dir 
\item dir изгражда лошия навик да се стряскам когато по инерция в DOS конзола напиша "dir -la" 
и видя празна диркетория.
\end{enumerate}

\section{Когато се нуждаем от помощ}

\subsection{man, whatis, apropos, info{\ldots}}

\man{man}{1} е най-често използвания инструмент за бързо достъпване на помощна информация за 
командите в Debian. Всъщност с man можем да видим доста повече информация, касаеща също така 
и системни извиквания, файлови формати и различни програми. Най-простото използване на
\man{man}{1} е когато подаваме един единствен аргумент --- името на командата (функцията, 
програмата и т.н.) за която искаме да получим информация. От там насетне, задачата на
\man{man}{1} е да открие страницата съдържаща съответния текст и да ни я покаже.

Нека опитаме да получим помощна информация за една друга важна команда в Debian ---
\man{cat}{1}.

\begin{verbatim}
manchev@shodan:~$man cat
\end{verbatim}

% $ -- затваряне на долара във verbatim

Екранът ще се изчисти и \man{man}{1} ще изведе страницата с помощна информация за
cat (FIXME: да се добави за разликата, когато man работи с \man{cat}{1} и с \man{less}{2}:
1. чрез cat може да се чете само "надолу"; 2. чрез less може да се използва PageUp,
PageDown) , която ще изглежда така:

\begin{verbatim}
Reformatting cat(1), please wait...
CAT(1)                           User Commands                          CAT(1)

NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [OPTION] [FILE]...

DESCRIPTION
       Concatenate FILE(s), or standard input, to standard output.

       -A, --show-all
              equivalent to -vET

       -b, --number-nonblank
              number nonblank output lines

       -e     equivalent to -vE

       -E, --show-ends
              display $ at end of each line

       -n, --number
--More--
\end{verbatim}

% $ -- затваряне на долара във verbatim
 
Когато текста предоставян ни от man не се събира на един единствен екран (както е в по-голямата 
част от случаите), \man{man}{1} показва първата страница, а на последния ред извежда 
инверсно "\verb#--More--#". Това ни показва, че \texttt{man} очаква команда, след като прочетем 
изведената информация. Това, което правим в повечето случаи е:

\begin{itemize}
\item натискаме space, което извежда следващата страница
\item натискаме Enter, което скролира текста с един единствен ред
\item натискаме q, което спира работата на man и ни връща в промпт
\end{itemize}

(FIXME: Като се говори за more, да се ref-не тук)

Нека обърнем внимание на още един факт: \man{man}{1} не само съдържа описание на информацията, 
а я държи и в структуриран формат. Когато изпълняваме \man{man}{1} и получаваме помощ, в горната 
лява и дясна част от изхода на командата, виждаме изписано името на параметъра който сме подали 
(респективно, за който получаваме информация - в нашия случай --- \man{cat}{1}). В скоби до 
него виждаме стойност, която ни показва от кой раздел получаваме информация. Ето и списък на 
отделните раздели:

\begin{enumerate}
\item Програми и команди на shell-a
\item Системни функции (които се предоставят от kernel-a)
\item Функции, реализирани в различни библиотеки
\item Файлове със специално предназначение (например тези в /dev)
\item Файлови формати и конвенции
\item Игри
\item Други
\item Команди свързани с администрирането на системата (в повечето случаи, достъпни само за root)
\item Специални функции на kernel-a
\end{enumerate}

Ключов момент е, че \man{man}{1} претърсва за подадения параметър разделите в точно определения 
ред и извежда първата страница, която открие. Възможно е параметъра, който подаваме на
\man{man}{1} да същесвува едновременно в няколко различни раздела. Именно затова \man{man}{1} 
резрешава да зададем в явен вид кой точно от разделите да се претърси за параметъра, без да се 
поглежда в другите части на документацията. Форматът на командата в този случай е:

\begin{verbatim}
man [име_на_раздел] какво_търсим
\end{verbatim}

Ако \man{man}{1} не открие търсенето в посочения раздел, той не претърсва останалите. Ако
зададем, например:

\begin{verbatim}
manchev@shodan:~$ man 1 cat
\end{verbatim} 

% $ -- затваряне на долара във verbatim

това ще работи коректно, защото така или иначе информацията за \man{cat}{1} е разположена в 
частта с програмите и различните \texttt{shell} команди. За сметка на това, ако зададем друга 
стойност на раздела (например 2) ще получим следното:

\begin{verbatim}
manchev@shodan:~$ man 2 cat
No manual entry for cat in section 2
See "man 7 undocumented" for help when manual pages are not available.
\end{verbatim}

% $ -- затваряне на долара във verbatim

Веднага изниква въпросът дали има възможност да видим в кой раздел е разположена информацията 
която търсим и дали за параметъра, съгласно който искаме информация от \man{man}{1}, не съществуват 
записи в повече от един раздел. Например, да предположим, че ни трябва описание на функцията
\texttt{clear}, която е част от библиотеката \texttt{curses} (поддържа функции за работа с екрана, 
които са терминално независими и следователно много полезни). За съжаление, ако просто изпълним 
\texttt{man clear} ще видим информация за командата (а не функцията) \texttt{clear}. Командата 
\man{clear}{1} се използва за изчистване на екрана и няма нищо общо с това, което на нас ни трябва.

В този случай може да ни помогне командата \man{whatis}{1}. Нека се върнем за момент към примерния 
изход от изпълнението на \texttt{man cat} показа по-горе. Още в самото начало на страницата, в частта 
\texttt{NAME} имаме името на командата, за която сме потърсили помощ (cat) и веднага след нея --- 
кратко нейно описание.

Това, което \man{whatis}{1} прави е да претърси всички раздели за страници отговарящи на името, 
което му подадем като параметър. После \man{whatis}{1} извежда списък, съдържащ съответно името, 
раздела и споменатото кратко описание. Да се върнем към случая с \texttt{clear} и да използваме 
\texttt{whatis}, за да си помогнем:

\begin{verbatim}
manchev@shodan:~$whatis clear
clear (1)         - clear the terminal window
clear (3ncurses)  - clear all or part of a curses window
\end{verbatim}

% $ -- затваряне на долара във verbatim

Ето защо получаваме не това, което ни трябва - командата \man{clear}{1} е разполжена в по-преден 
раздел от функцията clear и съответно е първото нещо, което \man{man}{1} ни показва. Сега, след 
като се уверихме че това, което ни трябва е в третия раздел, можем да го достъп по вече познатия начин:

\begin{verbatim}
manchev@shodan:~$man 3 clear
\end{verbatim}

% $ -- затваряне на долара във verbatim

Което ще ни даде точно това, което и търсехме.

Следващия въпрос, който е логично да си зададем е: След като имаме възможност да търсим по имена и 
да виждаме описание, не можем ли да направим търсенето така, че да бъде по думи споменати в описанието 
и така да получим самите имена, които после да разгледаме с \man{man}{1}? 

Разбира се, че е възможно. И тук на помощ ще дойде командата \man{apropos}{1}. Нека вземем следния 
пример --- искам да намеря такава команда, която да конвертира аудио диск в MP3 файлове, които да 
запиша в home директорията си и после да прослушвам с някакъв MP3 player.

Няма смисъл да си губим времето с \man{whatis}{1}. Да опитаме чрез \man{apropos}{1}:

\begin{verbatim}
manchev@shodan:~$apropos mp3
cdda2mp3 (1)        - extract audio CD audio tracks and encode them
\end{verbatim}

% $ -- затваряне на долара във verbatim

Звучи точно като това, което търсим. Представете си, колко щяхме да налучкваме с \man{whatis}{1}. 
От тук насетне можем веднага да погледнем:

\begin{verbatim}
manchev@shodan:~$man cdda2mp3
\end{verbatim}

% $ -- затваряне на долара във verbatim

и да видим как правилно да използваме \man{cdda2mp3}{1}. По въпроса за player-а можем да постъпим 
аналогично:

\begin{verbatim}
manchev@shodan:~$apropos player
xmms (1)            - an audio player for X.
xlsfonts (1x)       - server font list displayer for X
xprop (1x)          - property displayer for X
xwud (1x)           - image displayer for X
\end{verbatim}

% $ -- затваряне на долара във verbatim

На пръв поглед, първият запис май ни върши работа. Въпросът е, че зад него са се наредили още 
няколко, които нямат никакво отношение към нашия случай. Това се е случило, защото
\man{apropos}{1} търси стринга и в самите думи и е открил "player" в "displayer". В случая не е 
критчино, но когато имаме нужда от търсене точно на това което сме подали като параметър, можем 
да използваме опцията "-е" (exact --- точно съвпадение). Да опитаме:

\begin{verbatim}
manchev@shodan:~$apropos -e player
xmms (1)            - an audio player for X.
\end{verbatim}

% $ -- затваряне на долара във verbatim

Така нещата стоят по-нормално. Разбира се, в нашия случай не беше толкова критично, но е полезно 
да имаме "-е" предвид, когато apropos ни върне неподходящи резултати.

Освен гореспоменатите начини за набавяне на помощна информация, също така може да се
използва и \texttt{info}. GNU проектът разпространява голяма част от ръководствата
си в "info формат", който може да бъде прочетен, използвайки "info reader
(FIXME:четец)". За повече информация относно \texttt{info} можете да изпълните
командата:

\begin{verbatim}
$ info info
\end{verbatim}

% $ -- затваряне на долара във verbatim

FIXME: Да се добави повече инфо за info, например, за "браузването" в info и т.н.

Приключвайки с темата за man трябва да запомним едно основно правило: \man{man}{1}, 
\man{whatis}{1} и \man{apropos}{1} няма да ни помогнат много, когато инструмента или 
командата която ни е нужна не е инсталирана. Ако на вашата система нямате инсталиран \deb{xmms}, 
\texttt{apropos -e player} просто ще ви каже:

\begin{verbatim}
player: nothing appropriate
\end{verbatim}

Още повече, направете си труда да видите какво връща \texttt{apt-cache search player}, за да 
видите колко много и разнообразни player-и могат да бъдат инсталирани на вашия Debian. Така че, 
ако не намерите инструмента който ви трябва по някой от описаните по-горе начини.

\subsection{info}

Друга основна команда, която ни е нужна когато търсим помощна информация е \man{info}{1}. Тя 
се използва за четене на документи в Info формат. GNU разпространява голяма част от ръкводствата 
си в Info формат, затова е добре да можем да се справяме с инструмента за четене на този формат, 
а именно - Info.

Сега да опитаме нещо интересно --- да извикаме \man{info}{1} и да поискаме от него да ни покаже 
собствената си документацията. Ще процедираме точно като с \man{man}{1} --- предаваме един единствен 
параметър, показващ коя документация искаме да видим:

\begin{verbatim}
manchev@shodan:~$  info info
\end{verbatim}

% $ -- затваряне на долара във verbatim

Ето какво ще видим на екрана, след изпълнението на "info info"

\begin{verbatim}
File: info,  Node: Top,  Next: Getting Started,  Up: (dir)

Info: An Introduction
*********************

   Info is a program, which you are using now, for reading
documentation of computer programs.  The GNU Project distributes most
of its on-line manuals in the Info format, so you need a program called
"Info reader" to read the manuals.  One of such programs you are using
now.

   If you are new to Info and want to learn how to use it, type the
command `h' now.  It brings you to a programmed instruction sequence.

   To learn advanced Info commands, type `n' twice.  This brings you to
`Info for Experts', skipping over the `Getting Started' chapter.
   
* Menu:

* Getting Started::             Getting started using an Info reader.
* Advanced Info::               Advanced commands within Info.
* Creating an Info File::       How to make your own Info file.
--zz-Info: (info.gz)Top, 24 lines --Top----*** Tags out of Date ***-------------
Welcome to Info version 4.6. Type ? for help, m for menu item.
\end{verbatim}


Документацията във формат Info е разделена на различни части (nodes), според темата коят засягат. 
Да погледнем погледнем първия ред (или хедъра) на този node.Там изписан node-а, в който се намираме, 
както и този който следва след него. Виждаме, че различните раздели, които info ни показва са 
логически свързани един с друг. След като се запознаем със съдържанието на node "Top" (който в 
нашия случай е интродукция), следва да преминем към частта "Getting started". 

Из различните страници, които info извежда можем да навигираме с клавишите "n" (next - следваща) и 
"p" (previous - предходна). Ако натиснем "n" пред нас ще се изведе раздела "Getting started". 
Респективно ще се промени и хедъра, така че секция "Next" ще бъде "Advanced Info", а ще се появи и 
секция Prev --- "Top", която показва кой е разделът, предшестващ "Getting started".

Да натиснем "p", за да се върнем в "Top". Ако погледнем долната част на екрана, можем да
разберем, че тази страница е по-дълга от един екран. Ако информацията влизаше в рамките на екрана, 
долу щеше да бъде изписано "\verb#--All----#" вместо "\verb#--Top----#". За придвижване между 
страниците на текущия раздел използваме клавишите "PageUp" и "PageDown". Можем вместо тях да 
употребяваме и space и backspace, но ако с някой от тях достигнем границите на страницата, те 
автоматично ще ни прехвърлят към следващия(респективно предишния) раздел.

Освен линейното придвижване (чрез "n" и "p"), в info можем да използваме и менюта, чиито елементи 
водят директно към други раздели. Менюто можем да разпознаем по надписа "* Menu:". Всеки следващ 
елемент след "* Menu:" е връзка към друг раздел. В нашия случай (раздел "Top") имаме меню, както 
и определен брой елементи закачени към него:

\begin{verbatim}
* Menu:

* Getting Started::             Getting started using an Info reader.
* Advanced Info::               Advanced commands within Info.
* Creating an Info File::       How to make your own Info file.
\end{verbatim}

 
Основно има два подхода за навигация из менюто. Единият е просто да се придвижим до елемента със 
стрелките на клавиатурата (или Tab - елемент по елемент) и да натиснем Enter. Другият, макар и да 
изглежда по-неинтуитивен е много мощен и бърз. 

Другата възможност е да натиснем "m", което ще ни вкара в режим за работа с менюто. В долната 
част на екрана ще видим:

\begin{verbatim}
Menu item: 
\end{verbatim}

В този режим можем да напишем името на елемнта от менюто, а натискането на Enter ще ни прати в 
раздела, асоцииран с този елемент. Освен това:

\begin{itemize}
\item когато работим в този режим, можем да използваме клавиша Tab за автоматично дописване. 
Например, ако напишем "get" и натиснем Tab, info автоматично ще го превърне в "Getting Started". 
Ако има повече от една възможност, info ще ни го покаже над статусния ред, за да конкретизираме 
заявката си;
\item напускането на режима за навигация става чрез комбинацията Ctrl-g.
\end{itemize}


Последното, което ще споменм е, че когато навлизаме навътре в дървото от node-ове можем да 
използваме клавиша "u", който ни връща обратно нагоре по структурата.

Казаното до тук е една съвсем малка част от възможностите на \man{info}{1}. Ние можем да обхождаме 
различните раздели по име, да навигираме из подтеми по индекс, да редактираме info документи, да 
извършваме сложни търсения и още много други неща. Всички тези възможности може да научим направо 
от документацията на самото \man{info}{1} (\texttt{info info}). Не трябва да забравяме, че ако 
търсим нещо по-специфично, което не сме открили в \man{man}{1}, добре е да погледнем в
\man{info}{1}. Неговите раздели в повечето случаи са доста по-пълни и по-подробни.

\section{Навигация във файловата система}

Когато разгледахме командата \man{ls}{1} видяхме част от файловата структура на Debian. 
Тя е организирана в дървовидно --- концепция позната от множество операционни системи. 
Преди да видим как можем да се придвижвам из различните части на структурата (директориите), 
нека се запознаем с една друга команда - \man{pwd}{1}. Тя е изключително лесна и предназначението 
й е да покаже името на директорията, в която се намираме. Да опитаме:

\begin{verbatim}
manchev@shodan:~$ pwd
/home/manchev
manchev@shodan:~$
\end{verbatim}


В случая, командата показва директорията на потребителя като текуща, понеже до сега не сме 
навигирали извън нея. 

Ако погледнем описанието на \man{man}{1} за \man{pwd}{1} ще видим, че командата има две 
опции --- "\verb#--version#" и "\verb#--help#". Нека опитаме някоя от тях:

\begin{verbatim}
manchev@shodan:~$ pwd --help
-bash: pwd: --: invalid option
pwd: usage: pwd [-PL]
manchev@shodan:~$
\end{verbatim}


Изглежда "\verb#--help#" не е валидна опция за \man{pwd}{1}. Същото ще се случи, ако опитаме 
и с "\verb#--version#". Това е така, понеже повечето shell-ове като \man{bash}{1} имат собствена 
имплементация на \man{pwd}{1}, която се различава от описанията на man.

В случая с \deb{bash}, man няма да ни даде информация за реализацията на командата. За сметка на 
това, ако погледнем в info (info bash) ще видим описание на pwd. От там ще разберем, че pwd
на \deb{bash} има две валидни опции: "-P" и "-L", които контролират дали извежданото име на 
директория да съдържа или не символни линкове. 

След като веднъж знаем къде се намираме, нека опитаме да сменим текущата си директория. 
Това можем да постигнем чрез командата \texttt{cd}.

\subsection{cd}

\texttt{cd} променя текущата директория и приема един аргумент --- име на директорията, в която 
да се преместим (и тя да стане текуща). Ако извикаме \texttt{cd} без аргументи, тя по подразбиране 
ни връща в нашата \texttt{home} директория.

Да опитаме да се преместим в основната директория и после да се върнем в нашата собствена.

\begin{verbatim}
manchev@shodan:~$ cd /
manchev@shodan:/$ pwd
/
manchev@shodan:/$ cd
manchev@shodan:~$ pwd
/home/manchev
manchev@shodan:~$ 
\end{verbatim}

% $ -- затваряне на долара във verbatim

Видяхме как заедно се използват \texttt{cd} и \texttt{pwd}. При втората промяна на директория не 
използвахме параметър. В този случай:

\begin{verbatim}
manchev@shodan:/$ cd
\end{verbatim}

% $ -- затваряне на долара във verbatim

и

\begin{verbatim}
manchev@shodan:/$ cd /home/manchev
\end{verbatim}

% $ -- затваряне на долара във verbatim

се държат еквивалентно, така че съкратихме писането на аргумента. Командата \texttt{cd} е изключително 
проста. Всъщност, освен аргумента за директория, тя приема само още два параметъра --- "-P" и "-L", 
които са аналогични на тези от \man{pwd}{1}. Не трябва да забравяме, че ако все пак търсим помощна 
информация за \texttt{cd} трябва да погледнем чрез \texttt{man bash} или \texttt{info bash}, защото 
\texttt{cd} е също вградена команда за shell-а.

Докато се "разхождаме" из директориите виждаме, че при смяната на текущата директория bash prompt-ът 
се променя, отразявайки новата директория в която се намираме. Ако бяхме изпълнили \texttt{cd
/home}, той щеше да добие видa:

\begin{verbatim}
manchev@shodan:/home$
\end{verbatim}

% $ -- затваряне на долара във verbatim

В този случай бихме могли да се запитаме, дали тази функционалност не прави \man{pwd}{1} излишна. 
Е, определено не е така. Първо, командата може вместо да бъде веведена от нас, да бъде изпълнена в 
някакъв script (вътрешния език на shell-а) и тогавата нещата стоят малко по-различно. Освен това, 
дадена Debian система може да е така конфигурирана, че да не извежда подобна информация на prompt-а 
си, а ние трябва винаги лесно да можем да разберем къде се намираме.

Друго, което следва да се запитаме, защо тогава, когато сме в собствената си директория
(\texttt{/home/manchev}) prompt-ът изглежда по друг начин, вместо да ни показва името на директорията. 
В този случай знакът "~" има специално значение и то е да отговаря на собствената директория на 
конкретния потребител. Смисълът на тази функционалност ще видим след малко.

Има още една особеност на \texttt{cd}, която принципно важи и за много други команди : тя позволява 
подаваната чрез аргумент директория да бъде описана абсолютно или относително. Какъв е смисълът? 
Идеята е, че ако навигираме до директория \texttt{/home}, след което пожелаем да се озовем в
\texttt{/home/manchev} имаме два подхода:

\begin{verbatim}
manchev@shodan:/home$ cd /home/manchev
\end{verbatim}

% $ -- затваряне на долара във verbatim

и

\begin{verbatim}
manchev@shodan:/home$ cd manchev
\end{verbatim}

% $ -- затваряне на долара във verbatim

Във втория случай, когато аргументът не започва със знака "/" (който обозначава основната директория 
на дървото) командата предполага, че директорията която указваме е относителна спрямо текущото ни 
местоположение. Това предимство не е толкова явно в този случай, но ако си представим, че се намираме 
например в \texttt{/usr/X11R6/lib/modules/drivers} и искаме да се озовем в
\texttt{/usr/X11R6/lib/modules/drivers/linux} спестява доста писане. Нещо повече ---
\texttt{cd} разрешава да указваме не само име на директория, а и цялостен път, който също може да 
бъде абсолютен (от основната директория) или относителен (от текущото ни местоположение). В нашия 
пример ако в директория \texttt{manchev} имаше да кажем директория \texttt{backup}, вместо:

\begin{verbatim}
manchev@shodan:/home$ cd manchev
manchev@shodan:~$ cd backup
\end{verbatim}

можем да използваме:

\begin{verbatim}
manchev@shodan:/home$ cd manchev/backup
\end{verbatim}

% $ -- затваряне на долара във verbatim

Тук идва реда да се върнем към знака "~" и да видим колко полезен може да ни бъде, когато навигирме 
из файловата система на Debian. 
 
Да предположим, че се намираме в директория \texttt{/etc} и искаме да достигнем до поддиректория на 
нашата собствена (пак ще използваме измислената backup). От казаното до сега следва, че имаме два 
похода:

\begin{verbatim}
manchev@shodan:/etc$ cd
manchev@shodan:~$ cd backup
\end{verbatim}

или:

\begin{verbatim}
manchev@shodan:/etc$ cd /home/manchev/backup
\end{verbatim}

% $ -- затваряне на долара във verbatim

А ето как можем да използваме "~" и да си съкратим дългото писане или двете последователни изпълнения 
на \texttt{cd}:

\begin{verbatim}
manchev@shodan:/etc$ cd ~/backup
\end{verbatim}

% $ -- затваряне на долара във verbatim

Сега, нека приключим с \texttt{cd} и да видим как може да направим измислената директория
\texttt{backup} съвсем реална.
